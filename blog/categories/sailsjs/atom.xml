<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SailsJS | Jorge del Casar]]></title>
  <link href="http://jorgecasar.github.io/blog/categories/sailsjs/atom.xml" rel="self"/>
  <link href="http://jorgecasar.github.io/"/>
  <updated>2014-02-27T18:32:56+01:00</updated>
  <id>http://jorgecasar.github.io/</id>
  <author>
    <name><![CDATA[Jorge del Casar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Desarrollar Webapps Realtime: Auth con Passport y proveedores]]></title>
    <link href="http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-auth-con-passport-y-proveedores/"/>
    <updated>2014-01-22T10:13:37+01:00</updated>
    <id>http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-auth-con-passport-y-proveedores</id>
    <content type="html"><![CDATA[<div class="alert alert-info">
	<p>Código en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp">building-realtime-webapp</a>. Release: <code>auth-passport-providers</code>.</p>
	<p>Entorno de desarrollo en Heroku: <a href="http://building-realtime-webapp-dev.herokuapp.com/">building-realtime-webapp</a>.</p>
</div>

<p><img class="center" src="http://sailsjs.org/images/image_squidhome.png" title="‘Designed for developers by Giant Squid’ ‘Giant Squid’" ></p>

<ul id="markdown-toc">
  <li><a href="#instalar-y-configurar-dependencias">Instalar y configurar dependencias</a>    <ul>
      <li><a href="#fichero-de-configuracin">Fichero de configuración</a></li>
      <li><a href="#servicio-con-extrategias-externas">Servicio con extrategias externas</a></li>
    </ul>
  </li>
  <li><a href="#modificar-modelo-user">Modificar Modelo <code>User</code></a></li>
  <li><a href="#modificaciones-en-usercontroller">Modificaciones en <code>UserController</code></a></li>
  <li><a href="#personalizacin-de-rutas">Personalización de rutas</a>    <ul>
      <li><a href="#formulario-de-autenticacin">Formulario de autenticación</a></li>
      <li><a href="#nuevo-usuario">Nuevo usuario</a></li>
      <li><a href="#mostrar-usuario">Mostrar usuario</a></li>
    </ul>
  </li>
</ul>

<p>Tras ver <a href="/blog/desarrollar-webapps-realtime-auth/">cómo implementar un sistema de autenticación básica</a> y <a href="/blog/desarrollar-webapps-realtime-auth-con-passport/">cómo utilziar Passport para autenticar usuarios</a> vamos a dar un poso más y ver cómo autenticar usuarios usando otros proveedores como Github, Facebook o Twitter.</p>

<!-- more -->

<h2 id="instalar-y-configurar-dependencias">Instalar y configurar dependencias</h2>

<p>Como hemos dicho Passport es un sistema de autenticación modular y nos permite ir ampliando las formas de autenticar a nuestros usuarios. Puedes consultar la <a href="http://passportjs.org/guide/providers/">lista de proveedores de Passport</a> para ver todos los que están disponibles. Instalamos los paquetes que necesitemos:</p>

<pre><code>npm install --save passport-github passport-facebook passport-twitter
</code></pre>

<p>Una vez instalado los paquetes tenemos que configurar las estrategias. Como no quería depender de variables de entorno en local ni exponer las credenciales OAuth en un fichero de configuración, sin mencionar que necesitaremos credenciales diferentes para local y para producción. Por estas razones la solución que os planteo puede ser un poco rebuscada, pero por internet podéis encontrar formas más sencillas si no vais a hacer público vuestro código o decidis depender de variables de entorno.</p>

<h3 id="fichero-de-configuracin">Fichero de configuración</h3>

<p>Lo primero sería pensar en modificar el fichero de configuración. Pero hemos decidido dejar la configuración básica en este fichero y la declaración de estartegias externas en un servicio, debido a la necesidad de usar las variables de configuración de Sails (<code>sails.config</code>). Dado que la estrategia local funciona de fomra diferente y no requiere variables de configuración la hemos mantenido en el fichero de configuración. Los únicos cambios realizados a <code>/config/passport.js</code> son por temas de experiencia de usuario y para declarar los proveedores, que nos servirán para abstraer los proveedores que empleamos.</p>

<p>Pensando en el flujo de autenticación y que hacer cuando no se encuenta al usuario, independientemente del proveedor utilizado, la mejor solución es llevar al usuario a la página de registro, como veremos en el <code>UserController</code>. Si el usuario ha introducido su usuario (username o email) y contraseña, sería un detalle dejarle ese campo del formulario de registro relleno. Esto nos supone los siguientes cambios en nuestra estrategia local cuando no se encuenta el usuario:</p>

<p><code>javascript config/passport.js
[…]
if (!user) {
	var user = {};
	var re_email = /^(([^&lt;&gt;()[\]\\.,;:\s@\"]+(\.[^&lt;&gt;()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
	user[re_email.test(username)?'email':'username'] = username;
	return done(null, user, { message: 'Unknown user ' + username });
}
[…]
</code></p>

<h3 id="servicio-con-extrategias-externas">Servicio con extrategias externas</h3>

<p>Hemos creado un fichero en <code>/api/services/PassportService.js</code>, declarando las dependencias de proveedores de autenticación externos. Además declaramos la función, <code>providersHandler</code>, la cual se ejecutará una vez se haya autenticado en el servidor del proveedor. Esta función tiene como parámetros el token, el tokenSecret, el perfil de usuario y una función de callback que definimos cuando solicitamos la autenticación en nuestro controlador. En <code>providersHandler</code> se suele buscar o crear un usuario nuevo si no se encuentra, pero como nosotros tenemos nuestro sistema de usuarios y vamos a implementar varios proveedores, comprobaremos si el perfil está asociado a alguno de nuestros usuarios. Si el id del perfil está en nuestro Modelo devolvemos el usuario, en caso contraro, creamos un usuario un <strong>usuario temporal</strong> (sin guardarlo en la base de datos). Este usuario lo pasaremos al controlador mediante la función de callback para mantenerlo mientras el usuario termina de registrarse en nuestra plataforma y así poder asociar el perfil recibido sin necesidad de solicitar de nuevo la autenticación al proveedor.</p>

<p>```javascript /api/services/PassportService.js
var passport         = require(‘passport’),
    GitHubStrategy   = require(‘passport-github’).Strategy,
    FacebookStrategy = require(‘passport-facebook’).Strategy,
    TwitterStrategy  = require(‘passport-twitter’).Strategy;</p>

<p>function providersHandler(token, tokenSecret, profile, done) {
	sails.log.verbose(‘config/passport providersHandler’);
	process.nextTick(function () {
		User.findOne()
		.where({‘profiles.id’: profile.id})
		.done(function (err, user) {
			if (user) return done(null, user);</p>

<pre><code>		var tempUser = {}
		tempUser.profiles = []
		[…]
		tempUser.profiles.push(profile);
		delete profile._raw;
		delete profile._json;
		return done(err, tempUser);
	});
}); }; ```
</code></pre>

<p>Por último, el servicio exporta un módulo con una función que configura los proveedores con las variables de entorno o las de configuración de sails. Lo hacemos dentro de una función para disponer del objeto <code>sails</code> y por tanto de la configuración declarada en <code>/config/local.js</code> (hay una copia de referencia en <code>/config/local.ex.js</code>). Estas propiedades y métodos estarán disponibles en `sails.config</p>

<p><code>javascript /api/services/PassportService.js
module.exports = {
	configProviders: function(options, next) {
		passport.use(new GitHubStrategy(
			{
				clientID: process.env.GITHUB_CLIENT_ID || sails.config.providers.github.clientID,
				clientSecret: process.env.GITHUB_CLIENT_SECRET || sails.config.providers.github.clientSecret,
				callbackURL: process.env.GITHUB_CALLBACK_URL || sails.config.providers.github.callbackURL,
			},
			providersHandler
		));
		passport.use(new FacebookStrategy({
				[…]
			},
			providersHandler
		));
		passport.use(new TwitterStrategy({
				[…]
			},
			providersHandler
		));
	}
};
</code></p>

<p>Esta nueva función, <code>configProviders</code> debemos llamarla al iniciar la aplicaicón para que se configuren nuestros proveedores de autenticación. Para ello incluimos la llamada en <code>/config/bootstrap.js</code>:</p>

<p><code>javascript /config/bootstrap.js
module.exports.bootstrap = function (next) {
	PassportService.configProviders();
	next();
};
</code></p>

<h2 id="modificar-modelo-user">Modificar Modelo <code>User</code></h2>

<p>En el modelo solo tendremos que añadir un atributo más que guarde los perfiles del usuario. Los resultados se normalizan siguiendo el esquema de contacto establecido por Portable Contacts y puedes consultar en el <a href="http://passportjs.org/guide/profile/">perfil de usuario en Passport</a>. De momento Sails no permite las asociaciones, disponibles en la versión 0.10, así definiremos un array y procuraremos mantener el schema. Cuando pasemos a Sails.js 0.10 implementaremos asociaciones las cuales nos permitirán crear un modelo Profile en el que definieremos este schema.</p>

<p><code>javascript /api/models/User.js
module.exports = {
	attributes: {
		[…]
		profiles: {
			'array',
			defaultsTo: []
		}
		// Profiles object look like this:
		// provider: 'string',
		// id: 'string',
		// displayName: 'string',
		// name_familyName: 'string',
		// name_givenName: 'string',
		// name_middleName: 'string',
		// emails: 'array',
		// photos: 'array'
		[…]
	}
};
</code></p>

<h2 id="modificaciones-en-usercontroller">Modificaciones en <code>UserController</code></h2>

<p>Vamos a ampliar la funcionalidad de las acciones <code>login</code> y <code>logout</code>, las cuales nos permitirán realizar el login de un usuario y unir un perfil con el usuario registrado. Obtenemos el proveedor por parámetro (ver <a href="#personalizacin-de-rutas">Personalización de rutas</a>) y si es válido procederemos a la unión o eliminación del perfil. La url a la que haremos las peticiones será del tipo <code>/user/login/github</code>, siendo <code>github</code> lo que recibiremos como parámetro <code>provider</code>.</p>

<p><code>javascript /api/controllers/UserController.js
login: function(req, res, next) {
	var provider = req.param('provider') || 'local';
	if ( provider === 'local' || isProvider(provider) ) return linkProfile(provider, req, res, next);
	return res.redirect('/auth');
},
logout: function(req, res, next){
	var provider = req.param('provider');
	if ( isProvider(provider) ) return unlinkProfile(provider, req, res, next);
	req.logout();
	return res.redirect('/');
}
</code></p>

<p>Esto unido a tres funciones auxiliares resuelven de manera bastante elegante la autenticación de usuarios, enlace y desenlace de perfiles. La primera función auxiliar, <code>isProvider</code>, es para comprobar si es un proveedor de authenticación válido.</p>

<p><code>javascript /api/controllers/UserController.js
function isProvider(id){
	return sails.config.providers[provider];
}
</code>
La segunda, <code>linkProfile</code>, es la encargada de gestionar el login con dicho proveedor. Tendrá en cuenta si el usuario está registrado, si hemos encontrado un usuario con dicho perfil en nuestra base de datos y actuará en consecuencia en cada uno de los 5 casos:</p>

<ol>
  <li>Usuario registrado, intenta enlazar de nuevo un perfil ya enlazado.</li>
  <li>Usuario registrado, intenta enlazar un perfil asociado a otro usuario.</li>
  <li>Usuario registrado, intenta enlazar un perfil no asociado a ningún usuario.</li>
  <li>Usuario no registrado, se autentica con un perfil asociado a su usuario.</li>
  <li>Usuario no registrado, se autentica con un perfil no asociado a ningún usuario.</li>
</ol>

<h2 id="personalizacin-de-rutas">Personalización de rutas</h2>

<p>Un fichero que no habíamos visto hasta hora <code>/config/routes.js</code> hace aparición para que definamos las url de <code>login</code> y <code>logout</code>. El indicar en la url <code>:provider</code> establecemos <code>provider</code> como un parámetro y con <code>?</code> lo hacemos opcional. De esta forma estas urls nos sirven para el login general y para el login con un proveedor concreto.</p>

<p><code>javascript /config/routes.js
module.exports.routes = {
	'/': {
		view: 'home/index'
	},
	'/user/login/:provider?': 'UserController.login',
	'/user/logout/:provider?': 'UserController.logout'
};
</code>
## Cambios en las vistas</p>

<p>Ya tenemos toda la parte de lógica de negocio lista. Todo lo que hemos realizado en los controladores, modelos, cofig, servicios… tenemos que refejarlo en las vistas así que vamos a listar los cambios que hay que realizar.</p>

<h3 id="formulario-de-autenticacin">Formulario de autenticación</h3>

<ul>
  <li>Renombramos el fichero <code>/view/user/auth.ejs</code> a <code>/view/auth/index.ejs</code>.</li>
  <li>Cambiamos el action del formulario de autenticación a <code>/auth/login/local</code>.</li>
  <li>Añadimos los botones de autenticación de los diferentes proveedores que vamos a utilizar como formularios con action <code>/auth/login/[provider]</code>, siendo <code>[provider]</code> el proveedor que corresponda en cada caso. Para ello utilizamos utilizamos la variable <code>sails.config.providers</code> y un bucle <code>each</code>:</li>
</ul>

<p><code>html views/user/auth.ejs
&lt;% if ( sails.config.providers ) { %&gt;
&lt;div class="form-center"&gt;
	&lt;p class="text-center"&gt;&lt;%= __('or Auth with...') %&gt;&lt;p&gt;
	&lt;div class="row"&gt;
		&lt;% _.each(sails.config.providers, function(provider, provider_id){ %&gt;
		&lt;form role="form" action="/user/login/&lt;%= provider_id %&gt;" method="POST" class="col-xs-4"&gt;
			&lt;p&gt;
				&lt;button type="submit" class="btn btn-primary btn-block"&gt;
					&lt;!--span class="glyphicon glyphicon-&lt;%= provider_id %&gt;"&gt;&lt;/span--&gt;
					&lt;%= __(provider_id) %&gt;
				&lt;/button&gt;
			&lt;/p&gt;
		&lt;/form&gt;
		&lt;% }) %&gt;
	&lt;/div&gt;
&lt;/div&gt;
&lt;% } %&gt;
</code></p>

<h3 id="nuevo-usuario">Nuevo usuario</h3>

<p>Como hemos comentado guardamos un usuario temporal cuando no hemos encontrado el usuario en nuestra base de datos. Este es el momento de mostrarle al usuario los datos que había rellenado al intentar autenticarse. Hemos omitido poner la contraseña, porque es mejor introducirla de manera consciente. Este sería un ejemplo de como introducimos el valor del usuario temporal.</p>

<p><code>html views/user/new.ejs
&lt;input
	type="text"
	class="form-control"
	placeholder="&lt;%= __('Username') %&gt;"
	name="username"
	id="username"
	required
	&lt;% if( session.tempUser &amp;&amp; session.tempUser.username ) { %&gt;
	value="&lt;%= session.tempUser.username %&gt;"
	&lt;% } %&gt;/&gt;
</code></p>

<h3 id="mostrar-usuario">Mostrar usuario</h3>

<p>En la vista del usuario ahora tendremos que informarle de qué perfiles ha unido a su cuenta y darle la posibilidad de unir nuevos o eliminar los que tenga unidos. Así que iteramos los proveedores, <code>sails.config.providers</code> y si encontramos un perfil de ese proveedor entre los perfiles del usuario ofrecemos la opción de eliminar y en caso contrario la de añadir. Solo vamos a mostrar el condicional para mostrar el uso del método find:</p>

<p><code>html views/user/find.ejs
&lt;% if( _.find(
	user.profiles,
	function(profile) {
		return profile.provider == provider_id;
	}
) ) { %&gt;
</code></p>

<p>Con esto hemos terminado nuestro sistema de autenticación con proveedores externos y creado un sistema que facilita el deshabilitar o habilitar nuevos sistemas de autenticación.</p>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/c3e544e2ca9a890151959129f347667d43eb5209">c3e544e2ca: Auth with Passport and providers (GitHub, Facebook, Twitter).</a></p>
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/7eb75b35f1c878bb1f94039edb94ced5f7c7913b">7eb75b35f1: Delete verb from login and logout routes.</a></p>
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/0f78d3898b16702750d99a536434310ab3058a4f">0f78d3898b: Update read me and index to show read me info.</a></p>
</div>

<div class="alert alert-info">
	<p>Código en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp">building-realtime-webapp</a>. Release: <code>auth-passport-providers</code>.</p>
	<p>Entorno de desarrollo en Heroku: <a href="http://building-realtime-webapp-dev.herokuapp.com/">building-realtime-webapp</a>.</p>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Desarrollar Webapps Realtime: Auth con Passport]]></title>
    <link href="http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-auth-con-passport/"/>
    <updated>2014-01-19T19:39:54+01:00</updated>
    <id>http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-auth-con-passport</id>
    <content type="html"><![CDATA[<div class="alert alert-info">
	<p>Código en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp">building-realtime-webapp</a>. Release: <code>auth-passport</code>.</p>
	<p>Entorno de desarrollo en Heroku: <a href="http://building-realtime-webapp-dev.herokuapp.com/">building-realtime-webapp</a>.</p>
</div>

<p><img class="center" src="http://sailsjs.org/images/image_squidhome.png" title="‘Designed for developers by Giant Squid’ ‘Giant Squid’" ></p>

<ul id="markdown-toc">
  <li><a href="#instalar-y-configurar-passport">Instalar y configurar Passport</a></li>
  <li><a href="#acciones-login-y-logout">Acciones <code>Login</code> y <code>Logout</code></a></li>
  <li><a href="#polticas">Políticas</a></li>
  <li><a href="#actualizacin-de-vistas">Actualización de vistas</a></li>
</ul>

<p>En el artículo anterior vimos <a href="/blog/desarrollar-webapps-realtime-auth/">cómo implementar un sistema de autenticación básica</a>, y en esta ocasión vamos a implementar el sistema de autenticación usando <a href="http://passportjs.org/">Passport</a>. Passport es un middleware de autenticación para Node nos permitirá modularizar la autenticación de usuarios en nuestra aplicación y realizar inicio de sesión único con OAuth como Facebook o Twitter.</p>

<!-- more -->

<h2 id="instalar-y-configurar-passport">Instalar y configurar Passport</h2>

<p>Lo primero que tenemos que hacer es instalar Passport y los módulos que vayamos a utilizar. Empezaremos con una autenticación contra nuestra base de datos, así que necesitamos:</p>

<pre><code>npm install --save passport passport-local
</code></pre>

<p>Passport por defecto buscará en las peticiones el parámetro <code>username</code> y <code>password</code>, aunque podríamos cambiarlo, hemos optado por incluir el atributo <code>username</code> al modelo <code>User</code> (queda mejor que mostrar el email y podremos jugar con las rutas y el user name más adelante).</p>

<div class="alert alert-success">
	<p>Recomiendo echarle un ojo a la <a href="http://passportjs.org/guide/username-password/">Documentación de Passport local</a>.</p>
</div>

<p>Una vez instalado creamos un fichero de configuración en el directorio <code>config</code> llamado <code>passport.js</code>, el cual será cargado por Sails automáticamente al lanzar el servidor. Para no copiar todo el fichero aquí puesto que está disponible en GitHub voy a destacar lo más importante. Indicamos a passport que use una estrategia local, buscando un usuario cuyo <code>username</code> o <code>email</code> coincida con el campo username de nuestro fomulario de login. Una vez encontrado el usuario comparamos las contraseñas y devolvemos el usuario.</p>

<p><code>javascript config/passport.js
passport.use(new LocalStrategy(
	// options by default not needed.
	//{
	//	usernameField: 'username',
	//	passwordField: 'password'
	//},
	function(username, password, done) {
		process.nextTick(function () {
			User.findOne().where({
				or: [
					{ username: username },
					{ email: username }
				]
			}).done(function(err, user) {
				if (err) { return done(null, err); }
				if (!user) { return done(null, false, { message: 'Unknown user ' + username }); }
				bcrypt.compare(password, user.password, function(err, res) {
					if (!res) return done(null, false, { message: 'Invalid Password'});
					return done(null, user, { message: 'Logged In Successfully'} );
				});
			})
		});
	}
));
</code>
Unas lineas más abajo cerramos el fichero <code>passport.js</code> declarando el middleware de Express y asignando a las variables locales el usuario que devolvimos en el fragmento de código anterior:</p>

<p><code>javascript config/passport.js
module.exports = {
	express: {
		customMiddleware: function(app){
			sails.log.info('Express midleware for passport');
			app.use(passport.initialize());
			app.use(passport.session());
			app.use(function(req,res,next){
				res.locals.loggedUser = req.user;
				next();
			});
		}
	}
};
</code></p>

<h2 id="acciones-login-y-logout">Acciones <code>Login</code> y <code>Logout</code></h2>

<p>Ahora que tenemos configurado Sails para usar Passport realizamos los cambios en el controlador <code>UserController</code> para utilizar este nuevo medio de autenticación. Nuestras acciones <code>login</code> y <code>logout</code>quedan mucho más reducidas puesto que gran parte del trabajo lo hace Passport con las funciones <code>login</code> y <code>logout</code> que trae implementadas.</p>

<p><code>javascript api/controllers/UserController.js
[…]
login: function(req, res, next) {
	// Use Passport LocalStrategy
	require('passport').authenticate('local', function(err, user, info){
		if ((err) || (!user)) next(err);
		req.login(user, function(err){
			if (err) return res.redirect('/user/auth');
			// Redirect to the user page.
			return res.redirect('/user/' + user.id);
		});
	})(req, res);
},
logout: function(req, res){
	// Call Passport method to destroy the session.
	req.logout();
	// Redirect to home page.
	return res.redirect('/');
}
[…]
</code></p>

<h2 id="polticas">Políticas</h2>

<p>Como Passport nos facilita unos cuantos métodos para gestionar la autenticación del usuario vamos a aprovecharlos para usarlos en nuestras políticas. El primero de ellos es el método <code>isAuthenticated()</code>, el cual utilizaremos en la política con dicho nombre:</p>

<p><code>javascript api/policies/isAuthenticated.js
module.exports = function(req, res, next) {
	if ( req.isAuthenticated() ) return next();
	return res.forbidden('You are not permitted to perform this action.');
};
</code></p>

<p>Y otra de las tareas que automatiza es guardar el usuario registrado en la variable <code>req.user</code>, la cual usaremos para comprobar si puede administrar un usuario concreto.</p>

<p><code>javascript api/policies/canAdminUser.js
module.exports = function(req, res, next) {
	if (req.param('id') === req.user.id) return next();
	return res.forbidden('You are not permitted to perform this action.');
};
</code></p>

<h2 id="actualizacin-de-vistas">Actualización de vistas</h2>

<p>Y los últimos cambios que debemos realizar son en las vistas, los cuales enumero:</p>

<ul>
  <li>En los condicionales ya no usaremos <code>session.authenticated</code>, si no <code>loggedUser</code>.</li>
  <li>Para obtener los datos del usuario registrado utilizaremos <code>loggedUser</code> en lugar de <code>session.user</code>.</li>
  <li>En el formulario de autenticación, utilizaremos los campos <code>username</code> y <code>password</code>, indicando que el nombre de usuario puede ser también el correo-e.</li>
  <li>Añadiremos el campo <code>username</code> al formulario de registro y de edición.</li>
  <li>Mostraremos el nombre de usuario en lugar del mail en la ficha de usuario y en la barra de navegación.</li>
</ul>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/0c201f963d93f667622a7eb923ff9315a5503e4d">0c201f963d: Auth with Passport. Username attr added.</a></p>
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/34736d85b48333b0b17bb614f965bce351a0fb5a">34736d85b4: Fix session.canAdminUser using req.user. And login user on create.</a></p>
</div>

<div class="alert alert-info">
	<p>Código en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp">building-realtime-webapp</a>. Release: <code>auth-passport</code>.</p>
	<p>Entorno de desarrollo en Heroku: <a href="http://building-realtime-webapp-dev.herokuapp.com/">building-realtime-webapp</a>.</p>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Desarrollar Webapps Realtime: Auth]]></title>
    <link href="http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-auth/"/>
    <updated>2014-01-18T12:40:04+01:00</updated>
    <id>http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-auth</id>
    <content type="html"><![CDATA[<div class="alert alert-info">
	<p>Código en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp">building-realtime-webapp</a>. Release: <code>auth</code>.</p>
	<p>Entorno de desarrollo en Heroku: <a href="http://building-realtime-webapp-dev.herokuapp.com/">building-realtime-webapp</a>.</p>
</div>

<p><img class="center" src="http://sailsjs.org/images/image_squidhome.png" title="‘Designed for developers by Giant Squid’ ‘Giant Squid’" ></p>

<ul id="markdown-toc">
  <li><a href="#cambios-en-el-layout">Cambios en el layout</a></li>
  <li><a href="#autenticacin-bsica">Autenticación básica</a>    <ul>
      <li><a href="#accin-auth">Acción <code>auth</code></a></li>
      <li><a href="#accin-login">Acción <code>Login</code></a></li>
      <li><a href="#accin-logout">Acción <code>Logout</code></a></li>
    </ul>
  </li>
  <li><a href="#polticas-de-acceso">Políticas de acceso</a>    <ul>
      <li><a href="#poltica-usuario-autenticado">Política usuario autenticado</a></li>
      <li><a href="#poltica-de-poder-administar-usuario">Política de poder Administar usuario</a></li>
    </ul>
  </li>
</ul>

<p>Siguiendo con la saga de “Desarrollar Webapps Realtime” y depués de haber visto <a href="/blog/desarrollar-webapps-realtime-creacion">Cómo empezar a crear un Webapp real-time</a> y <a href="/blog/desarrollar-webapps-realtime-usuarios">cómo crear usuarios siguiendo el patrón MVC</a>, le toca el turno a cómo autenticar a los usuarios en nuestra plataforma. Para ello vamos a hacerlo primero con nuestros propios medios para entender algunos conceptos y después lo haremos usando <a href="http://passportjs.org/">Passport for Node</a>.
<!-- more --></p>

<h2 id="cambios-en-el-layout">Cambios en el layout</h2>

<p>Lo primero que vamos a hacer es cambiar la barra de navegación añadiendo el botón de login cuando el usuario no esté autenticado y su correo y el boton de logout cuando si lo esté. Para ello debemos comprobar la variable <code>session.authenticated</code> que estableceremos en el controlador. Estas líneas las añadimos después de nuestro menú de navegación, <code>&lt;ul class="nav navbar-nav"&gt;[…]&lt;/ul&gt;</code>:</p>

<p><code>html layout.ejs
&lt;% if( session.authenticated ) { %&gt;
&lt;ul class="nav navbar-nav navbar-right"&gt;
	&lt;li&gt;&lt;a href="http://jorgecasar.github.io/user/&lt;%= session.user.id %&gt;"&gt;&lt;%= session.user.email %&gt;&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;
		&lt;form class="navbar-form" action="/user/logout" method="POST"&gt;
			&lt;button type="submit" class="btn btn-danger" title="&lt;%= __('Logout')%&gt;"&gt;
				&lt;%= __('Logout')%&gt;
				&lt;span class="glyphicon glyphicon-log-out"&gt;&lt;/span&gt;
			&lt;/button&gt;
		&lt;/form&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;% } else { %&gt;
&lt;ul class="nav navbar-nav navbar-right"&gt;
	&lt;li&gt;&lt;a href="http://jorgecasar.github.io/user/new"&gt;&lt;span class="glyphicon glyphicon-edit"&gt;&lt;/span&gt; Sign up&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href="http://jorgecasar.github.io/user/auth"&gt;&lt;span class="glyphicon glyphicon-log-in"&gt;&lt;/span&gt; Login&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;% } %&gt;
</code></p>

<p>Si os fijáis para crear un nuevo usuario y para la página de autenticación he usado enlaces pero para el log out he usado un formulario con un botón. Esto es porque en los enlaces se utilizan para navegar y los botones para acciones.</p>

<h2 id="autenticacin-bsica">Autenticación básica</h2>

<p>Para gestionar las sesiones necesitaremos las acciones <code>auth</code>, <code>login</code> y <code>logout</code>. Estas acciones las vamos a añadir en <code>UserController</code>, aunque podrían ir en un nuevo controlador llamado <code>SessionController</code>. Como posteriormente vamos a implementar la autenticación con Passport lo moveremos a un controlador especifico llamado <code>AuthController</code>.</p>

<h3 id="accin-auth">Acción <code>auth</code></h3>

<p>Esta acción simplemente nos devolverá una vista con el formulario de autenticación. Así que habrá que crear la vista <code>/view/user/auth.ejs</code> en la que le solicitaremos el email y la contraseña. Esta vista es muy similar a <code>/view/user/new.ejs</code>, así que podemos copiar y pegar el contenido y hacemos un par de cambios:</p>

<ul>
  <li>El action del from ya no es <code>/user/create</code> sino <code>/user/login</code>.</li>
  <li>Los 3 textos (migas de pan, título y botón) donde pone ‘Create user’ ponemos ‘Auth user’.</li>
</ul>

<p>Y en el controlador copiamos la acción new sin hacer ningún cambio.</p>

<p><code>javascript auth action in UserController.js
auth: function(req, res) {
	return res.view();
}
</code></p>

<p>Ahora podemos lanzar el servidor y comprobar que la url <a href="http://localhost:1337/user/auth">http://localhost:1337/user/auth</a> funciona correctamente.</p>

<h3 id="accin-login">Acción <code>Login</code></h3>

<p>En esta acción hay un poco más de chicha, ya que tendremos que buscar el usuario mediante el email, comparar la contraseña y guardar una variable de sessión.</p>

<p><code>javascript login action in UserController.js
login: function(req, res) {
	User.findOne({email: req.param('email')}).done(function foundUser(err, user){
		if ( err || !user ) return res.redirect('/auth');
		require('bcrypt').compare(req.param('password'), user.password, function(err, valid){
			if(err || !valid ) return res.redirect('/auth');
			req.session.authenticated = true;
			req.session.user = user;
			return res.redirect('/user/' + user.id);
		});
	});
}
</code></p>

<p>Si lanzamos el servidor de nuevo y probamos a rellenar el formulario con uno de los usuarios previamente creados, vemos como nos redirecciona a la página del usuario y nos reemplaza los botones de ‘Ingresar’ y ‘Resistrarse’ por el email del usuario y un botón de ‘Desconectar’.</p>

<p>Tenemos que tener en cuenta que cunado se crea un usuario podemos considerarlo autenticado. O bien esperar a que verifique su mail, pero como de momento no enviamos mail. Consideraremos al usuario autenticado al crear la nueva cuenta, asignando los valores a la sesión antes de enviar la respuesta:</p>

<p><code>javascript create action in UserController.js
create: function(req, res, next) {
	User.create( req.params.all(), function createdUser(err, user){
		[…]
		req.session.authenticated = true;
		req.session.user = user;
		[…]
	});
}
</code></p>

<h3 id="accin-logout">Acción <code>Logout</code></h3>

<p>En este caso, es mucho más facil, simplemente destruimos la sesión y redirigimos al usuario a la home.</p>

<p><code>javascript logout action in UserController.js
logout: function(req, res){
	req.session.destroy();
	return res.redirect('/');
}
</code></p>

<p>Volvemos a lanzar el servidor, hacemos login y una vez en la página del usuario pulsamos el botón de ‘Desconectar’ para ver como salimos de la sessión y vuelven a aparecer los botones de ‘Ingresar’ y ‘Resistrarse’.</p>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/01e14ef420a8d238c08f9ee4ece91f3df8b08737">01e14ef420: Authentication on UserController: auth, login and logout actions</a>.</p>
</div>

<h2 id="polticas-de-acceso">Políticas de acceso</h2>

<div class="alert alert-success">
	<p>Recomiendo echarle un ojo a la <a href="http://sailsjs.org/#!documentation/policies">Documentación de Sails sobre Políticas</a>.</p>
</div>

<p>Autenticar a un usuario tiene la misión principal de conceder o denegar el acceso a algunas partes de nuestra aplicación. Para ello haremos uso de las políticas (policies). Estas políticas las declaramos en el directorio <code>/api/policies</code>.</p>

<h3 id="poltica-usuario-autenticado">Política usuario autenticado</h3>

<p>Por defecto Sails nos incluye la política <code>isAuthenticated.js</code>. La cual hace uso de la variable de sessión que establecemos a <code>true</code> cuando el usuario se identifica. Una politica se declara como un módudo y ejecuta la función de callbac <code>next</code> cunado se concede acceso o devuelve forbidden en caso contrario.</p>

<p><code>javascript /api/policies/isAuthenticated.js
module.exports = function(req, res, next) {
	if (req.session.authenticated)
		return next();
	return res.forbidden('You are not permitted to perform this action.');
};
</code></p>

<p>Ahora que tenemos la políca definida debemos aplicarla a alguna URL o acción del controlador. Para ello accedemos a <code>/config/policies.js</code> donde definiremos las políticas que se aplcian en cada caso.</p>

<p><code>javascript /config/policies.js
module.exports.policies = {
	'*': true,
	UserController: {
		'*': true,
		find: 'isAuthenticated',
		update: 'isAuthenticated',
		destroy: 'isAuthenticated',
		edit: 'isAuthenticated',
		logout: 'isAuthenticated'
	}
}
</code></p>

<p>Con esto estamos permitiendo el acceso a todas las acciones del <code>UserController</code>, y en algunos casos (find, update, destroy, edit, logut), le pedimos que estén autenticados. Personalmente prefiero aplicar las políticas partiendo de la restricción, es decir, para todas las acciones hay que estar autenticado salvo para las que definamos como abiertas. Quedaría de esta manera:</p>

<p><code>javascript /config/policies.js
module.exports.policies = {
	'*': true,
	UserController: {
		'*': 'isAuthenticated',
		create: true,
		new: true,
		auth: true,
		login: true
	}
}
</code></p>

<p>En ambos casos permitimos el acceso a las mismas url, pero si añadimos una acción al controlador, estará protegida por defecto.</p>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/e58ea71cc3f566287e67e64eaabbf1838652912c">e58ea71cc3: isAuthenticated policy</a>.</p>
</div>

<h3 id="poltica-de-poder-administar-usuario">Política de poder Administar usuario</h3>

<p>Para los casos de editar y eliminar, debemos asegurarnos de que el usuario es él mismo, para evitar que un usuario pueda editar o eliminar cuentas que no son la suya. Más adelante podremos establecer perfiles administradores que también puedan realizar esas acciones, por eso vamos a llamar a la política <code>canAdminUser</code>:</p>

<p><code>javascript /api/policies/canAdminUser.js
module.exports = function(req, res, next) {
	if (req.param('id') === req.session.user.id)
		return next();
	return res.forbidden('You are not permitted to perform this action.');
};
</code></p>

<p>Además tendremos que actualizar nuestras políticas:</p>

<p><code>javascript /config/policies.js
[…]
UserController: {
	'*': ['isAuthenticated', 'canAdminUser'],
	find: 'isAuthenticated',
	update: 'isAuthenticated',
	logout: 'isAuthenticated',
	create: true,
	new: true,
	auth: true,
	login: true
}
[…]
</code></p>

<p>Ahora si intentamos editar o eliminar un usuario no podremos. Así que deberíamos quitar los botones de la interfaz de usuario para reducir la generación de errores. Por lo que añadimos este condicional para mostrar las opciones sólo en caso necesario.</p>

<p><code>html /views/user/find.ejs
[…]
&lt;%
if ( session.user.id === user.id ) {
// There logged user and showed user is the same.
%&gt;
&lt;form action="/user/destroy/&lt;%= user.id %&gt;" method="POST"&gt;[…]&lt;/form&gt;
&lt;% } %&gt;
[…]
</code></p>

<p>Una solución más elegante para no tener que aplicar esta lógica en la template sería utilizar la variable session.canAdminUser. Una forma más elegante, que delega la responsibilidad de la lógica al controlador, que es quien lo debe hacer.</p>

<p>```javascript find action in UserController.js 
find: {
	[…]
	if ( isShortcut(id) ) return next();</p>

<pre><code>req.session.canAdminUser = canAdminUser(id, req.session.user);

[…]

function canAdminUser(id, sessionUser){
	return sessionUser &amp;&amp; sessionUser.id === id;
}; } ```
</code></pre>

<p>De esta forma si cambiamos las políticas de acceso a la página de listado de usuarios nos aseguramos que solo verán las acciones editar y eliminar aquellos que puedan ejecutarlas.</p>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/01a7287d07509d9f90cb440cb6af828847ece9fe">01a7287d07: Can Admin User Policy</a>.</p>
</div>

<div class="alert alert-info">
	<p>Código en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp">building-realtime-webapp</a>. Release: <code>auth</code>.</p>
	<p>Entorno de desarrollo en Heroku: <a href="http://building-realtime-webapp-dev.herokuapp.com/">building-realtime-webapp</a>.</p>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Desarrollar Webapps Realtime: Usuarios]]></title>
    <link href="http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-usuarios/"/>
    <updated>2014-01-16T09:28:14+01:00</updated>
    <id>http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-usuarios</id>
    <content type="html"><![CDATA[<div class="alert alert-info">
	<p>Código en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp">building-realtime-webapp</a>. Release: <code>users</code>.</p>
	<p>Entorno de desarrollo en Heroku: <a href="http://building-realtime-webapp-dev.herokuapp.com/">building-realtime-webapp</a>.</p>
</div>

<p><img class="center" src="http://sailsjs.org/images/image_squidhome.png" title="‘Designed for developers by Giant Squid’ ‘Giant Squid’" ></p>

<ul id="markdown-toc">
  <li><a href="#configuracin-del-almacenamiento">Configuración del almacenamiento</a>    <ul>
      <li><a href="#configuracin-en-heroku">Configuración en Heroku</a></li>
      <li><a href="#admin-ui-para-mongodb">Admin UI para MongoDB</a></li>
    </ul>
  </li>
  <li><a href="#generar-mvc-para-user">Generar MVC para <code>User</code></a>    <ul>
      <li><a href="#probar-bd-y-api">Probar BD y API</a></li>
      <li><a href="#modelo-user">Modelo <code>User</code></a>        <ul>
          <li><a href="#encriptar-contrasea">Encriptar contraseña</a></li>
        </ul>
      </li>
      <li><a href="#controlador-usercontroller">Controlador <code>UserController</code></a></li>
      <li><a href="#vista-user">Vista <code>User</code></a></li>
    </ul>
  </li>
</ul>

<p>Hace unos días vimos <a href="/blog/desarrollar-webapps-realtime-creacion/">cómo crear webapps realtime</a> y hoy vamos a implementar la gestión de usuarios. Podemos hacerlo de forma básica o usando algun middleware como <a href="https://github.com/jaredhanson/passport">Passport</a> o <a href="https://github.com/bnoguchi/everyauth">Everyauth</a>. En este artículo empezaremos creando el controlador y el modelo <code>User</code> y posterior mente haremos la integración con un middleware para ampliar y mejorar la gestión de usuarios.
<!-- more --></p>

<p>Si quieres empezar desde este punto y seguir el manual paso a paso puedes clonar el repositorio desde la release <a href="https://github.com/jorgecasar/building-realtime-webapp/releases/tag/init">init</a>:</p>

<pre><code>$ git clone https://github.com/jorgecasar/building-realtime-webapp.git
$ git checkout init
</code></pre>

<h2 id="configuracin-del-almacenamiento">Configuración del almacenamiento</h2>

<p><img class="pull-right dark" src="http://media.mongodb.org/logo-mongodb.png" title="‘MongoDB’" ></p>

<p>Sails proporciona un ORM (Object Relational Mapping) llamado <a href="https://github.com/balderdashy/waterline">Waterline</a> para normalizar las interacciones con modelos. De esta forma nos podemos olvidar del origen de los datos (una vez configurado, claro). Nosotros atacamos al modelo con los métods que veremos a continuación y el waterline se encargará de almacenarlos y recuperarlos del origen. De esta forma especificamos el esquema de nuestra base de datos y podremos utilizar PostgreSQL, MySQL, MongoDB, Memory, Disk, Redis, Riak, IRC, Twitter, JSDom o cualquiera que nos desarrollemos como fuente de nuestros datos.</p>

<p>Nosotros vamos a utiliar <a href="http://www.mongodb.org/">MongoDB</a> para almacenar nuestros datos. Si no tenéis instalado MongoDB podéis consultar el <a href="http://docs.mongodb.org/manual/installation/">manual de instalación de MongoDB</a>. Después tenemos que incluir el paquete de node <code>sails-mongo</code>, que nos incluirá el waterline <a href="https://github.com/balderdashy/sails-mongo">sails-mongo</a> y eliminar la dependencia de <code>sails-disk</code>.Añadimos el flag <code>--save</code> para que modifique las dependencias de <code>package.json</code>, añadiendo y quitando, respectivamente:</p>

<pre><code>$ npm install --save sails-mongo
$ npm uninstall --save sails-disk
</code></pre>

<p>Ahora tenemos que pasar por la configuración puesto que por defecto utiliza el Waterline Disk. Abrimos el fichero: <code>confi/adapters.js</code> y añadimos lo siguiente:</p>

<pre><code>'default': 'mongo',
[…]
mongo: {
	module: 'sails-mongo',
	url: process.env.DB_URL, // variable de entorno.
	schema: true
}
</code></pre>

<p>Como véis hemos utilizado una variable de entorno para no exponer nuestros datos de configuración de producción si subimos el código a algún repositorio público.</p>

<p>Todo el proyecto lo vamos subiendo a un entorno en la nube, en mi caso Heroku, así que vamos a ver cómo dar de alta un <em>Add-on</em>:</p>

<h3 id="configuracin-en-heroku">Configuración en Heroku</h3>

<div class="alert alert-success">
	<p>Recomiendo echarle un ojo a la <a href="https://devcenter.heroku.com/articles/config-vars">documentación de Heroku sobre variables de configuración</a>.</p>
</div>

<p>Para añadir complementos a Heroku podmeos hacerlo desde el panel de control de heroku entrando en nuestra aplicación y en la sección recursos hacemos click en <a href="https://addons.heroku.com/?app=building-realtime-webapp-dev">Get Add-ons</a>. Aquí podemos buscar el complemento que necesitamos, en este caso buscando por Mongo nos aparen dos: <a href="https://addons.heroku.com/mongohq#sandbox">MongoHQ</a> y <a href="https://addons.heroku.com/mongolab#sandbox">MongoLab</a>. Como MongoHQ no está disponible en Europa, no nos queda otra que optar por MongoLab. La versión gratuita es muy parecida en ambos y da de sobra para entornos de desarrollo, así que nos facilitan la elección. Al final de la tabla de características encontráis la posibiliad de incluir el complemento a alguna de vuestras aplicaciones y el código para ejecutarlo en consola.</p>

<pre><code>$ heroku addons:add mongolab --app building-realtime-webapp-dev
</code></pre>

<p>Hemos incluido el nombre de la app porque en el directorio tenemos 2 aplicaciones Heroku, la de producción y la de desarrollo, así que de momento lo incluímos en la desarrollo.</p>

<p>Heroku nos incluye una variable de entorno con la cadena de conexión a la base de datos llamada <code>MONGOLAB_URI</code>, podemos usar esa directamente en nuestro <code>adapter.js</code> o bien crearnos la que habíamos elegido, <code>DB_URL</code>. Para obtener la url podemos copiar la que nos incluye Heroku y luego añadir la nuestra:</p>

<pre><code>$ heroku config --app building-realtime-webapp-dev
MONGOLAB_URI: mongodb://[user]:[password]@[host]:[port]/[database]
$ heroku config:set DB_URL=mongodb://[user]:[password]@[host]:[port]/[database] --app building-realtime-webapp-dev
</code></pre>

<p>Podemos sobrescribir esta configuración para que nos funcione en local modificando el fichero <code>config/local.js</code>. La configuración pude hacerse indicando cada una de los atributos por separado o mediante la <a href="http://docs.mongodb.org/manual/reference/connection-string/">cadena de conexión</a> que aglutina todos los atributos en un solo script.</p>

<pre><code>adapters: {
	'default': 'mongo',
	mongo: {
		module: 'sails-mongo',
		// Config by parts. Sails will generate the connection uri
		host: 'localhost',
		user: '',
		password: '',
		database: 'building-realtime-webapp',
		schema: true
		// Config by connection URI.
		// url: mongodb://localhost/building-realtime-webapp
	}
}
</code></pre>

<p>Antes de seguir, vamos a comprobar que todo funciona correctamente. Debemos abrir 2 consolas para:</p>

<ul>
  <li>
    <p>El demonio de MongoDB:</p>

    <pre><code>  $ mongod
  all output going to: /usr/local/var/log/mongodb/mongo.log
</code></pre>
  </li>
  <li>
    <p>Levantar el proyecto, como ya sabemos: <code>$ sails lift</code> o `$ foreman start</p>
  </li>
</ul>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/5f34185918b05b3648f14213f23ae32b88404262">5f34185918: Config MongoDB as default adapter</a>.</p>
</div>

<h3 id="admin-ui-para-mongodb">Admin UI para MongoDB</h3>
<p>MongoDB no incluye por defecto ningún administrador de bases de datos visual. Con el comando <code>mongo</code> entramos en la consola de MongoDB y podemos realizar consultas. Como no tenemos ningún modelo, Sails todavía no ha crado la base de datos ni las colecciones, así que no os asustéis si véis la base de datos vacía.</p>

<p>Personalmente, opino que la línea de comandos está muy bien y recomiendo que siempre le echéis un ojo y la conozcáis antes de pasar a herramientas con Interfaz de Usuario. En <a href="http://docs.mongodb.org/ecosystem/tools/administration-interfaces/">Mongo Administration Interfaces</a> tenéis unas cuantas herramientas. Para visualizar la base de datos suelo usar <a href="http://genghisapp.com/">Genghis</a> y si voy a tener que administrarla, haciendo consultas, exportaciones, etc… uso <a href="https://github.com/fotonauts/MongoHub-Mac">MongoHub</a>.</p>

<h2 id="generar-mvc-para-user">Generar MVC para <code>User</code></h2>

<p>Sails.js ofrece una serie de generadores como ya vimos en el artículo anterior y esta vez vamos a utilizar el generador de modelo y controlador. Si quisiéramos sólo crear el modelo o el controllador especificaríamos <code>model</code> o <code>controlller</code> después de <code>generate</code>, respectivamente. Pero en este caso necesitaremos ambos:</p>

<pre><code>$ sails generate user
info: Generating model and controller for user...
</code></pre>

<p>Si nos fijamos en el directorio <code>/api</code> veremos que contiene las siguientes carpetas:</p>

<ul>
  <li>adapters</li>
  <li>controllers</li>
  <li>models</li>
  <li>policies</li>
  <li>services</li>
</ul>

<p>Como os podéis imaginar el comando anterior nos ha creado los ficheros <code>/api/models/User.js</code> y <code>/api/controllers/UserController.js</code>.</p>

<p>Sails por defecto tiene una serie de blueprints, todos activados por defecto.</p>

<ul>
  <li>Action: Todas las acciones creadas en el controlador serán accesibles mediante la url: <code>/&lt;controller&gt;/&lt;action&gt;</code>.
    <ul>
      <li>/user -&gt; UserController.index</li>
      <li>/user/index -&gt; UserController.index</li>
      <li>/user/sendEmail -&gt; UserController.sendEmail</li>
      <li>/user/[action] -&gt; UserController[action]</li>
    </ul>
  </li>
  <li>REST: Expone un API REST convencional por encima del controlador con las acciones: <code>find</code>, <code>create</code>, <code>update</code>, and <code>destroy</code> asociados a sus respectivos verbos:
    <ul>
      <li>GET -&gt; /user/:id? -&gt; UserController.find</li>
      <li>POST -&gt; /user -&gt; UserController.create</li>
      <li>PUT -&gt; /user/:id -&gt; UserController.update</li>
      <li>DELETE -&gt; /user/:id -&gt; UserController.destroy</li>
    </ul>
  </li>
  <li>Shortcuts: Nos permite acceder a los <em>métods CRUD</em> (Create, Read, Update y Delete) desde la barra de direcciones del navegador:
    <ul>
      <li>/user/find/[id] -&gt; Devuelve la información del usuario con id = [id]</li>
      <li>/user/create?name=<name> -&gt; Crea un nuevo usuario</name></li>
      <li>/user/update/[id]?name=<newname> -&gt; Actualiza el nombre del usuario con id = [id]</newname></li>
      <li>/user/delete/[id] -&gt; Elimina el usuario con id = [id]</li>
    </ul>
  </li>
</ul>

<p>Todas estas acciones podemos dejarlas activadas en desarrollo para facilitarlos algunas tareas. Pero en el entorno de producción, las acciones y el API REST podemos dejarlos activados, pero los atajos habrá que deshabilitarlos. Esta configuración puedes modificarla en cada <em>Controller</em> o de manera global en <code>config/controllers.js</code>.</p>

<h3 id="probar-bd-y-api">Probar BD y API</h3>
<p>Ahora si volvemos a lanzar nuestro servidor (<code>sails lift</code>) podemos realizar algunas pruebas y ver la potencia de Sails recién salido de la caja. La primera es comprobar que la base de datos se ha crado correctamente.</p>

<ul>
  <li>
    <p>Por línea de comandos:</p>

    <pre><code>  $ mongo
  &gt; use building-realtime-webapp
  switched to db building-realtime-webapp
  &gt; show collections
  system.indexes
  user
</code></pre>
  </li>
  <li>
    <p>Con Genghis:</p>

    <pre><code>  $ genghisapp
  Starting 'genghisapp'...
  'genghisapp' is already running at http://0.0.0.0:5678
</code></pre>

    <p>Entramos en <a href="http://0.0.0.0:5678">http://0.0.0.0:5678</a> y navegamos por nuestro servidor <a href="http://0.0.0.0:5678/servers/localhost">localhost</a> &gt; <a href="http://0.0.0.0:5678/servers/localhost/databases/building-realtime-webapp">building-realtime-webapp</a> &gt; <a href="http://0.0.0.0:5678/servers/localhost/databases/building-realtime-webapp/collections/user">user</a></p>
  </li>
</ul>

<p>Parece que todo funciona, ahora le toca el turno a los <em>blueprints</em>. Antes de probar las siguientes URLs, debéis hacer un cambio en <code>config/local.js</code> y poner a <code>schema: false</code>. Esto hará que no tengamos un esquema de la base de datos definido y podamos introductir cualquier atributo a la colección. Con <code>schema: true</code>, sólo se guradarán los atributos que hayamos definido en <code>/api/models/User.js</code>. Os recomiendo que probéis a cambiar la configuración de los <em>blueprints</em> en <code>config/controllers</code> y la del esquema para ver las diferentes configuraciones y podáis entender qué sucede con nuestro velero. Recordad que hay que alzar las velas (<code>sails lift</code>) con cada cambio de configuración.</p>

<ul>
  <li>Mostrar la lista de usuarios: <a href="http://localhost:1337/user">http://localhost:1337/user</a>.</li>
  <li>Añadir el usuario “Jorge”: <a href="http://localhost:1337/user/create?name=Jorge">http://localhost:1337/user/create?name=Jorge</a>.</li>
  <li>Buscar el usuarios con nombre “Jorge”: <a href="http://localhost:1337/user?name=Jorge">http://localhost:1337/user?name=Jorge</a>.</li>
  <li>Modificar el usuario “Jorge” (usar el id de la consulta anterior): <a href="http://localhost:1337/user/update/[id]?name=Jorge del Casar">http://localhost:1337/user/update/[id]?name=Jorge del Casar</a></li>
</ul>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/153a53883a8a4c209ac3a5aa3bc8f0e6f9633eba">153a53883a: Create Model and Controller for User</a>.</p>
</div>

<h3 id="modelo-user">Modelo <code>User</code></h3>

<div class="alert alert-success">
	<p>Recomiendo echarle un ojo a la <a href="http://sailsjs.org/#!documentation/models">Documentación de Sails sobre Modelos</a>.</p>
</div>

<p>En el archivo <code>/api/model/User.js</code> especificamos los atributos necesarios. Empezaremos simplemente con email y contraseña:</p>

<p><code>javascript User Model
module.exports = {
	attributes: {
		email: {
			type: 'string',
			required: true,
			email: true,
			unique: true
		},
		password: {
			type: 'string',
			required: true
		}
	}
}
</code></p>

<p>Salis nos permite crear nuestros propios métodos y sobrescribir los métodos <code>toObject</code> y <code>toJSON</code> (se especifican en attributes). Veamos un ejemplo de ambos para evitar que la contraseña llegue al cliente:</p>

<p><code>javascript User Model
attributes: {
	[…]
	// Override toJSON instance method to remove password value
	toJSON: function() {
		var obj = this.toObject();
		delete obj.password;
		return obj;
	}
}
</code>
Ahora si volvemos a levantar el servidor y probamos introducir un nuevo usuario: <a href="http://localhost:1337/user/create?email=someone@somewhere.com&amp;password=securePass007">http://localhost:1337/user/create?email=someone@somewhere.com&amp;password=securePass007</a>. Vemos que el JSON que nos devuelve el servidor no incluye el atributo password, pero si visualizamos la base de datos (<a href="http://localhost:5678/servers/localhost/databases/building-realtime-webapp/collections/user">http://localhost:5678/servers/localhost/databases/building-realtime-webapp/collections/user</a>, vemos que si se ha guardado correctamente.</p>

<h4 id="encriptar-contrasea">Encriptar contraseña</h4>
<p>Guardar la contraseña directamente en la base de datos es una mala práctica, así que vamos a ver cómo encriptarla usando el paquete <code>bcrypt</code>. Instalamos y guardamos la dependencia ejecutando:</p>

<pre><code>$ npm install --save bcrypt
</code></pre>

<p>Sails nos ofrece una serie de <em>callbacks</em> del ciclo de vida del modelo para que podamos unirnos en cualquier parte del proceso de la consulta:</p>

<ul>
  <li>Callbacks al crear:
    <ul>
      <li>beforeValidation: <code>fn(values, cb)</code></li>
      <li>beforeCreate: <code>fn(values, cb)</code></li>
      <li>afterCreate: <code>fn(newlyInsertedRecord, cb)</code></li>
    </ul>
  </li>
  <li>Callbacks al actualizar:
    <ul>
      <li>beforeValidation: <code>fn(valuesToUpdate, cb)</code></li>
      <li>beforeUpdate: <code>fn(valuesToUpdate, cb)</code></li>
      <li>afterUpdate: <code>fn(updatedRecord, cb)</code></li>
    </ul>
  </li>
  <li>Callbacks al eliminar:
    <ul>
      <li>beforeDestroy: <code>fn(criteria, cb)</code></li>
      <li>afterDestroy: <code>fn(cb)</code></li>
    </ul>
  </li>
</ul>

<p>En nuestro caso necesitamos ejecutarla al crear, aunque más adelante tendremos que dar la posibilidad al usuario de actualizar su contraseña y por tanto debemos encriptarla al actualizar también:</p>

<p>```javascript User Model
module.export = {
	[…]
	// Lifecycle Callbacks
	beforeCreate: function(values, next) {
		hashPassword(values, next);
	},
	beforeUpdate: function(values, next) {
		if(values.password) hashPassword(values, next);
		else next();
	}
};</p>

<p>var bcrypt = require(‘bcrypt’);</p>

<p>function hashPassword(values, next) {
	bcrypt.hash(values.password, 10, function(err, hash) {
		if (err) return next(err);</p>

<pre><code>	values.password = hash;
	next();
}); } ```
</code></pre>

<p>Ahora si volvemos a levantar el servidor y probamos introducir un nuevo usuario: <a href="http://localhost:1337/user/create?email=other@somewhere.com&amp;password=securePass007">http://localhost:1337/user/create?email=other@somewhere.com&amp;password=securePass007</a>. Vemos que la contraseña es una cadena de caracteres inlegible (<a href="http://localhost:5678/servers/localhost/databases/building-realtime-webapp/collections/user">http://localhost:5678/servers/localhost/databases/building-realtime-webapp/collections/user</a>.</p>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/5137c5a1bb9cc3decb257da5ed6677e804ad487d">153a53883a: Define User Model and include bcryp package</a>.</p>
</div>

<p>En el siguiente commit hemos añadido un método para verificar la contraseña, puesto que lo utilizaremos para comprobar que es correcta cuando queremos cambiarla. También hemos mejorado la callback beforeUpdate añadiendo la lógica necesaria para cambiar la contraseña, verificando que la anterior es correcta y que la nueva se introduce correctamente 2 veces. Por último hemos mejorado el método hashPassword generando un salt previo al hash. Están todas las lineas comentadas así que es fácil ver que se hace en cada una de ellas.</p>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/e881b5cba8996ae883396ecb6c84e3758f984dbc">e881b5cba8: Added method validPassword, improved methods beforeUpdate and hashPassword</a>.</p>
</div>

<div class="alert alert-danger">
	<h5><a href="https://github.com/jorgecasar/building-realtime-webapp/issues/1">Issue #1: Check password beforeValidation instead of beforeUpdate</a>.</h5>
	<p>La contraseña es un atributo obligatorio en en el modelo del usuario, por lo tanto al comprobar la validez de los datos nos saltará un error si no la introducimos. Por ello, las comprobaciones que hacíamos en beforeUpdate hay que hacerlas en beforeValidation para evitar que falle al no introducir contraseña. Además hay que comprobar mediante el id si no esncontramos en una cración o en una actualización de usuario.</p> 
</div>

<h3 id="controlador-usercontroller">Controlador <code>UserController</code></h3>

<div class="alert alert-success">
	<p>Recomiendo echarle un ojo a la <a href="http://sailsjs.org/#!documentation/controllers">Documentación de Sails sobre Controladores</a>.</p>
</div>

<p>Ahora que tenemos nuestro modelo <code>User</code> listo vamos a incluir unas acciones en nuestro <code>UserController</code> que nos permitirán interactuar con nuestros modelos de una forma más avanzada que las acciones por defecto. Se han mantenido las acciones estandar para estar en consonancia con la API REST y los Sortcurs CRUD, para evitar tener que cambiar routes, que ya veremos en siguientes artículos cómo hacerlo.</p>

<ul>
  <li>Acciones REST:
    <ul>
      <li><strong>find</strong>: Atenderá las peticiones <code>GET</code> a <code>/user/:id?</code>. La ‘?’ significa que el parámetro <code>id</code> es opcional. Por lo que el controlador está preparado para buscar un usuario por id o varios en función de lo especificado en el where. Además se podrán limitar, saltar y ordenar los resultados.</li>
      <li><strong>create</strong>: Resolverá las peticiones <code>POST</code> a <code>/user</code>, creando un usuario y devolviendo la instancia creada.</li>
      <li><strong>update</strong>: Se encargará de las peticiones <code>PUT</code> a <code>/user/:id</code>. El parámetro id es obligatorio puesto que no se permite la edición múltiple de usuarios.</li>
      <li><strong>destroy</strong>: Eliminará el usuario con id especificado mediante la petición <code>DELETE</code> a <code>/user/:id</code></li>
    </ul>
  </li>
  <li>Acciones adicionales:
    <ul>
      <li><strong>edit</strong>: Devolverá la vista <code>edit</code>, la cual contendrá el formulario de edición con los valores precargados.</li>
      <li><strong>new</strong>: devolverá la vista <code>new</code> con un formularo para la creación de un nuevo usuario.</li>
    </ul>
  </li>
</ul>

<p>Por no copiar todo el controlador aquí, voy a destacar las parte que me parecen más interesantes, puesto que el resto lo tenéis en GitHub. Vamos a empzar con un fragmento de la acción <code>find</code> que permite, filtrar y paginar los resultados. Gracias a estas 10 lineas podrás hacer consultas a urls como: <a href="http://localhost:1337/user/?where={&quot;email&quot;:{&quot;contains&quot;:&quot;somewhere.com&quot;}}&amp;limit=2&amp;sort=email DESC">http://localhost:1337/user/?where={“email”:{“contains”:”somewhere.com”}}&amp;limit=2&amp;sort=email DESC</a> y obtener como máximo 2 usuarios ordenados de manera descendente cuyos emails contengan “somewhere.com”.</p>

<p><code>javascript User Controller
	find: function(req, res, next) {
		[…]
		// If we have a where param we will pase it as JSON.
		var where = req.param('where');
		if( _.isString(where)) {
			where = JSON.parse(where);
		}
		// Setting options from params.
		var filters = {
			limit: req.param('limit') || undefined,
			skip: req.param('skip')  || undefined,
			sort: req.param('sort') || undefined,
			where: where || undefined
		};
		// Find users according with filters
		User.find(filters).done(function foundUsers(err, users){
			[…]
		});
		[…]
	}
</code></p>

<p>Otra parte interesante es la forma de devolver los resultados, ya que antes de hacerlo comprobamos qué tipo de respuesta se nos está solicitando. En caso de solicitar JSON devolvemos los resultados en JSON y en caso contraro le pasamos los resultados a la vista correspondiente.</p>

<p><code>javascript User Controller
	[…]
	// Response JSON if needed.
	if (req.wantsJSON) return res.json(user);
	// Else response view with results 
	else return res.view({ user: user });
	[…]
</code></p>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/046d2301bf754f4b99c7abeb4b02faf137d4c502">046d2301bf: UsarController: API REST friendly</a>.</p>
</div>

<h3 id="vista-user">Vista <code>User</code></h3>

<div class="alert alert-success">
	<p>Recomiendo echarle un ojo a la <a href="http://sailsjs.org/#!documentation/views">Documentación de Sails sobre vistas</a>.</p>
</div>

<p>Por último, tendremos que crear una vista para mostrar los resultados. Si os fijáis no hemos definido el nombre de la vista ya que Sails asocia por defecto cada acción de un controlador a la vista localizada en <code>/views/[controlador]/[acción]</code>. Sabiendo esto debemos crear el directorio <code>/view/user</code> y los ficheros <code>find.ejs</code>, <code>new.ejs</code> y <code>edit.ejs</code>. El resto de acciones no se reflejarán en una vista por lo cual no las necesitamos.</p>

<p>Antes de enseñar las peculiaridades de las vistas he incluido <a href="http://getbootstrap.com/">Bootstrap</a> y <a href="http://jquery.com/">jQuery</a> (dependencia de Bootstrap) en el directorio <code>/assets/linker/js</code> y los estilos de Bootstrap en <code>assets/linker/styles/</code>. De esta manera se incluyen automáticamente en el layout. Para asegurarnos que el orden es el correcto abrimos el fichero <code>/Gruntfile.js</code> y lo modificamos indicando el orden de inclusión de los recursos:</p>

<p>```javascript Gruntfile.js
var cssFilesToInject = [
	‘linker/styles/bootstrap.css’,
	‘linker/styles/bootstrap-theme.css’,
	‘linker/<em>*/</em>.css’
];</p>

<p>var jsFilesToInject = [
	[…]
	// <em>-&gt;    put other dependencies here   &lt;-</em>
	‘linker/js/jquery.js’,
	‘linker/js/bootstrap.js’,
	[…]
];
```
&lt;div class="alert alert-info"&gt;
	&lt;p&gt;Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/e3479ce836a6baacd89491d893b43aeacf7d0452">e3479ce836: Include jQuery and Bootstrap. Modify GruntFile to set the order</a>.&lt;/p&gt;
&lt;/div&gt;</p>

<p>Las vistas en si no tienen mucho misterio. Destacar que Sails utiliza el motor de templates <a href="http://embeddedjs.com/">EJS: Embebed Javascript</a>, lo cual me recuerda mucho a PHP donde puedes mezclar código de scripting con HTML. Afortunadamente, todos sabemos que eso es una mala práctica y hay que dejarle la lógica al controlador y utilizar en las vistas la menor posible. Para este artículo, al no estar dedidaco a las vistas no he querido complicarlas mucho incluyendo partials, cambiando el layout o indicando la vista desde el controlador, pero que sepáis que se puede hacer y ya vermos cómo en otros artículos.</p>

<div class="alert alert-info">
	<p>Commit en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp/commit/3785bbe071dcf8cf4ee12cd75ac0ab5570dec342">3785bbe071: Included User views. Modified index and layout. Include some styles to customize Bootstrap</a>.</p>
</div>

<p>Ahora que tenemos todo subido podemos hacer un push al entorno de desarrollo:</p>

<pre><code>$ git push heroku-dev develop:master
</code></pre>

<p>Y por último podemos ver el resultado en <a href="http://building-realtime-webapp-dev.herokuapp.com/">http://building-realtime-webapp-dev.herokuapp.com/</a>:</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Desarrollar webapps realtime: Creación]]></title>
    <link href="http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-creacion/"/>
    <updated>2014-01-10T10:30:09+01:00</updated>
    <id>http://jorgecasar.github.io/blog/desarrollar-webapps-realtime-creacion</id>
    <content type="html"><![CDATA[<div class="alert alert-info">
    <p>Código en GitHub: <a href="https://github.com/jorgecasar/building-realtime-webapp">building-realtime-webapp</a>. Release: <code>init</code>.</p>
</div>

<p><img class="center" src="http://sailsjs.org/images/image_squidhome.png" title="‘Designed for developers by Giant Squid’ ‘Giant Squid’" ></p>

<ul id="markdown-toc">
  <li><a href="#crear-proyecto-con-sailsjs">Crear proyecto con Sails.js</a>    <ul>
      <li><a href="#requisitos">Requisitos</a></li>
      <li><a href="#instalacin">Instalación</a></li>
      <li><a href="#crear-un-nuevo-proyecto">Crear un nuevo proyecto</a></li>
    </ul>
  </li>
  <li><a href="#crear-un-repositorio-git">Crear un repositorio git</a>    <ul>
      <li><a href="#repositorio-git-remoto-en-github">Repositorio git remoto en GitHub</a></li>
      <li><a href="#primer-commit">Primer commit</a></li>
    </ul>
  </li>
  <li><a href="#despliegue-en-heroku">Despliegue en Heroku</a>    <ul>
      <li><a href="#requisitos-1">Requisitos</a></li>
      <li><a href="#configuracin-local">Configuración local</a></li>
      <li><a href="#crear-una-aplicacin-en-heroku">Crear una aplicación en Heroku</a></li>
      <li><a href="#desplegar-el-cdigo">Desplegar el código</a></li>
    </ul>
  </li>
</ul>

<p>Hace unos meses descubrí Sails.js, un framework MVC para Node basado en Express que te facilita la creación de aplicaciones web realtime mediante Websockets. Así que no me extraña que el slogan sea:
<blockquote><p>THE WEB FRAMEWORK OF YOUR DREAMS.<br/>Designed for developers by Giant Squid.</p><footer><strong>Mike McNeil,</strong> <cite><a href='http://sailsjs.org/'>Creator of sails.js</a></cite></footer></blockquote>
<!-- more --></p>

<h2 id="crear-proyecto-con-sailsjs">Crear proyecto con Sails.js</h2>

<h3 id="requisitos">Requisitos</h3>
<p><img class="pull-right dark" src="http://nodejs.org/images/logo.png" title="‘Node.js’" >
Obviamente necesitamos tener <a href="http://nodejs.org/">Node.js</a>. En mi caso, tengo la última versión estable, la 0.10.24, puesto que voy a desplegar en Heroku y acepta cualquier versión superior a la 0.8.5. Os recomiendo revisar qué versión hay instalada en el servidor donde vayáis a hacer despliegue de producción. Para comprobar la versión que tienes en local, ejecuta en la consola: <code>node -v</code>. Para gestionar la versión de node os recomiendo el paquete <a href="https://npmjs.org/package/n"><code>n</code> de npm</a>. Lo instalais globalmente para tenerlo disponible desde cualquier parte y luego podrás instalar la versión última versión estable con el comando <code>sudo n stable</code></p>

<h3 id="instalacin">Instalación</h3>
<p>Podemos instalar <a href="http://sailsjs.org/">Sails.js</a> local o globalmente (flag -g)el paquete sails:</p>

<p><div>
  <pre><code class='plain'>$ sudo npm -g install sails</code></pre>
</div>
</p>

<h3 id="crear-un-nuevo-proyecto">Crear un nuevo proyecto</h3>
<p>Tenemos que llamar al commando <code>new</code> que nos creará un proyecto sails en la carpeta <code>&lt;appName&gt;</code> en el directorio desde donde lo ejecutemos.</p>

<p><div>
  <pre><code class='plain'>$ sails new &lt;appname&gt; [--linker]
$ cd &lt;appname&gt;</code></pre>
</div>
</appname></appname></p>

<p>También existe la opción de usar un enlazador de recursos automático añadiendo la flag <code>--linker</code>. Esto instalará una tarea de <a href="http://gruntjs.com/">Grunt</a> llamada <a href="https://github.com/balderdashy/grunt-sails-linker">grunt-sails-linker</a> que automatiza la adición de etiquetas html basadas en ficheros. Incluyendo la flag sails creará el <code>Gruntfile.js</code> implementando esta tarea de Grunt.</p>

<p>Con el proyecto creado y estando en su directorio podremos lanzarlo:</p>

<p><div>
  <pre><code class='plain'>$ sails lift</code></pre>
</div>
</p>

<p>Una vez lanzado, vemos que el barco ha zarpado y podemos ver nuestra webapp en <a href="http://localhost:1337">http://localhost:1337</a></p>

<h2 id="crear-un-repositorio-git">Crear un repositorio git</h2>
<p><img class="pull-right" src="http://git-scm.com/images/logo@2x.png" title="‘Git’" >
Es muy recomendable tener un control de versiones aunque sea simplemente en local para poder deshacer cambios y tener un flujo de trabajo controlado.</p>

<p><div>
  <pre><code class='plain'>$ git init</code></pre>
</div>
</p>

<p>Además, quién sabe si mañana no eres tú solo el que toca el código. Así que, inicializamos un git y enviamos lo que llevamos. Os recomiendo echarle un ojo al <a href="http://nvie.com/posts/a-successful-git-branching-model/">modelo de ramificación Git acertado</a>.</p>

<p><img class="center" src="http://nvie.com/img/2009/12/Screen-shot-2009-12-24-at-11.32.03.png" title="‘A successful Git branching model’" ></p>

<p>De momento vamos a crear únicamente las ramas <code>master</code> y <code>develop</code> para nuestro proyecto y según vayamos necesitando las demás las vamos creando a partir de la rama que corresponda.</p>

<p><div>
  <pre><code class='plain'>$ git checkout -b master &amp;amp;&amp;amp; git checkout -b develop</code></pre>
</div>
</p>

<p>De esta manera nos quedamos en la rama <code>develop</code> para empezar ahí nuestro proyecto y cuando tengamos algo estable lo combinaremos con la rama <code>master</code>.</p>

<h3 id="repositorio-git-remoto-en-github">Repositorio git remoto en GitHub</h3>
<p>En mi caso, voy a usar <a href="http://github.com">GitHub</a> para compartir mi código con todos vosotros. Creamos nuestro nuevo repositorio en GitHub e incluimos la url del repositorio a nuestro proyecto:</p>

<p><div>
  <pre><code class='plain'>$ git remote add origin &lt;git_url&gt;</code></pre>
</div>
</git_url></p>

<h3 id="primer-commit">Primer commit</h3>
<p>Ahora que tenemos nuestro repositorio git es hora de hacer el primer commit:</p>

<p><div>
  <pre><code class='plain'>$ git add .
$ git commit -m “First commit”
$ git push -u origin develop</code></pre>
</div>
</p>

<h2 id="despliegue-en-heroku">Despliegue en Heroku</h2>
<p><img class="pull-right" src="https://d1lpkba4w1baqt.cloudfront.net/heroku-logo-light-300x100.png" title="‘Heroku’" >
Una vez tenemos nuestro proyecto en local vamos a ver si nos funciona correctamente en el servidor de producción. Voy a describir los pasos claves, pero si tienes algún problema puedes echarle un ojo <a href="https://devcenter.heroku.com/articles/getting-started-with-nodejs">Empezar con Node.js en Heroku</a> y <a href="https://devcenter.heroku.com/articles/git">Desplegando con git</a> para obtener información adicional.</p>

<h3 id="requisitos-1">Requisitos</h3>
<p>Antes de empezar necesitaremos un par de cosas:</p>

<ol>
  <li><a href="https://id.heroku.com/signup/devcenter">Crear una cuenta en Heroku</a></li>
  <li>Instalar las <a href="https://toolbelt.heroku.com/">Heroku Toolbelt</a></li>
</ol>

<h3 id="configuracin-local">Configuración local</h3>
<p>Después de instalar las Toolbelt tendrás disponible el comando <code>heroku</code> en tu consola. Así que vamos a registrarnos en Heroku y configurar nuestro entorno:</p>

<p><div>
  <pre><code class='shell'>$ heroku login</code></pre>
</div>
</p>

<p>Nos pedirá nuestro nombre de usuario, contraseña y si queremos crear una llave pública SSH (<em>SSH public key</em>) para poder publicar nuestro código posteriormente.</p>

<p>Es recomendable indicar en el ```package.json`` la versión de node que queremos utilizar para evitar problemas y asegurarnos que estamos usando una versión que soportamos.</p>

<p>~~~ json
“engines”: {
    “node”: “0.10.x”
}
~~</p>

<p>Heroku usa el fichero <em>Procfile</em> para indicar los comandos que va a ejecutar la aplicación, así que le tenemos que indicar que queremos un comando de tipo web y que ejecute nuestro script de Node.js:</p>

<p><div>
  <pre><code class='plain'>web: node app.js</code></pre>
</div>
</p>

<p>Ahora podemos arrancar la aplicación usando <a href="https://github.com/ddollar/foreman">Foreman</a>, que también lo tendrás instalado como parte de las ToolBelt:</p>

<p><div>
  <pre><code class='shell'>$ foreman start</code></pre>
</div>
</p>

<p>Seguramente te de un error porque no encuentra el módulo <code>sails</code>, así que instala las dependencias para tener una copia de sails en node_modules, puesto que al tenerlo instalado globalmente foreman no lo encuentra.</p>

<p><div>
  <pre><code class='shell'>$ npm install</code></pre>
</div>
</p>

<p>Si todo funciona correctamente, subimos nuestro nuevo fichero al repositorio:</p>

<p><div>
  <pre><code class='plain'>$ git add .
$ git commit -m “Added Procfile”
$ git push origin develop</code></pre>
</div>
</p>

<h3 id="crear-una-aplicacin-en-heroku">Crear una aplicación en Heroku</h3>
<p>Heroku utiliza git para la gestión del código, así que tendremos que crear la aplicación en Heroku y poner una referencia en nuestra lista de repositorios remotos.</p>

<p><div>
  <pre><code class='shell'>$ heroku apps:create &lt;appname&gt; --remote &lt;remote&gt; --region eu</code></pre>
</div>
</remote></appname></p>

<p>Esto creará una aplicación <code>&lt;appName&gt;</code> en Heroku, creará un repositorio remoto llamado <code>&lt;remote&gt;</code> (por defecto, heroku) e indicamos que nuestra región es Europa.</p>

<p>Si tenemos la aplicación creada en Heroku, podemos añadirla como repositorio remoto:
<div>
  <pre><code class='shell'>$ heroku git:remote -a &lt;appname&gt;</code></pre>
</div>
</appname></p>

<p>Debido a que tenemos la rama maestra y la de desarrollo, y Heroku sólo tiene en cuenta la rama master para los despliegues en sus servidores, recomiendo crear otra app en Heroku para desarrollo. Yo lo he hecho añadiendo <code>-dev</code> tanto al nombre de la app con al nombre del repositorio remoto.</p>

<p><div>
  <pre><code class='shell'>$ heroku apps:create &lt;appname&gt;-dev --remote &lt;remote&gt;-dev --region eu</code></pre>
</div>
</remote></appname></p>

<h3 id="desplegar-el-cdigo">Desplegar el código</h3>
<p><img class="pull-left no-border" src="http://sailsjs.org/images/image_devInTub.png" title="‘Sails lift’" >
Hasta ahora solo hemos subido el código a la rama <code>develop</code> por lo que tendremos que desplegar en la rama master de <code>heroku-dev</code>.</p>

<p><div>
  <pre><code class='shell'>$ git push heroku-dev develop:master</code></pre>
</div>
</p>

<p>Veremos cómo detecta que es una aplicación Node.js, instala las dependencias, cachea node_modules para futuros despliegues, construye el entorno, parsea el Procfile comprime y lanza. Ahora podemos ver nuestra webapp en el entorno de pre-producción <a href="http://building-realtime-webapp-dev.herokuapp.com">http://building-realtime-webapp-dev.herokuapp.com</a></p>
]]></content>
  </entry>
  
</feed>
